<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>加解密、签名验证总结</title>
    <link href="/2024/09/09/%E5%8A%A0%E8%A7%A3%E5%AF%86%E3%80%81%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E6%80%BB%E7%BB%93/"/>
    <url>/2024/09/09/%E5%8A%A0%E8%A7%A3%E5%AF%86%E3%80%81%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1>加解密、签名验证总结</h1><p>因为做试用期的小功能，实际使用了一下这方面的框架，总结一下。<br>我选择的方案是用python加密和签名，在Java端解密和验证。这里有个重要的点就是两方的方案包括参数要对的上。</p><h2 id="对称加密（加解密）">对称加密（加解密）</h2><p>比较简单，大部分能找到的代码都是可以直接用的。<br>我选用的方法是<code>AES</code>，需要注意的地方是我这里<code>symmetric_key</code>是Base64编码的，如果从文件读取，需要先解码。<br>生成密钥</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64  <br><span class="hljs-keyword">import</span> os  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_symmetric_key</span>():  <br><span class="hljs-keyword">return</span> os.urandom(<span class="hljs-number">32</span>) <span class="hljs-comment"># 生成 256-bit 对称密钥  </span><br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encode_key_to_base64</span>(<span class="hljs-params">key</span>):  <br><span class="hljs-keyword">return</span> base64.b64encode(key).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_key_to_file</span>(<span class="hljs-params">key, filename</span>):  <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:  <br>f.write(encode_key_to_base64(key))  <br>  <br>  <br>key = generate_symmetric_key()  <br>save_key_to_file(key, <span class="hljs-string">&#x27;symmetric_key.key&#x27;</span>)<br></code></pre></td></tr></table></figure><p>加密</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">data: <span class="hljs-built_in">str</span>, symmetric_key: <span class="hljs-built_in">bytes</span></span>) -&gt; <span class="hljs-built_in">str</span>:  <br><span class="hljs-comment"># 生成 12 字节的随机 noncenonce = os.urandom(12)  </span><br>cipher = AES.new(symmetric_key, AES.MODE_GCM, nonce=nonce)  <br>encrypted_data, tag = cipher.encrypt_and_digest(data.encode())  <br><span class="hljs-comment"># 返回 nonce 和加密数据（包括 GCM tag）  </span><br><span class="hljs-keyword">return</span> base64.b64encode(nonce + encrypted_data + tag).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure><p>解密(Java)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decrypt</span><span class="hljs-params">(String data, <span class="hljs-type">byte</span>[] symmetricKey)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>    <span class="hljs-type">byte</span>[] encryptedData = Base64.getDecoder().decode(data);  <br>    <span class="hljs-type">byte</span>[] nonce = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">12</span>];  <br>    <span class="hljs-type">byte</span>[] tag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">16</span>];  <br>    <span class="hljs-type">byte</span>[] ciphertext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[encryptedData.length - <span class="hljs-number">12</span>];  <br>  <br>  <br>    System.arraycopy(encryptedData, <span class="hljs-number">0</span>, nonce, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>);  <br>    System.arraycopy(encryptedData, encryptedData.length - <span class="hljs-number">16</span>, tag, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);  <br>    System.arraycopy(encryptedData, <span class="hljs-number">12</span>, ciphertext, <span class="hljs-number">0</span>, ciphertext.length);  <br>  <br>    <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">&quot;AES/GCM/NoPadding&quot;</span>);  <br>    <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">keySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(symmetricKey, <span class="hljs-string">&quot;AES&quot;</span>);  <br>    cipher.init(Cipher.DECRYPT_MODE, keySpec, <span class="hljs-keyword">new</span> <span class="hljs-title class_">GCMParameterSpec</span>(<span class="hljs-number">128</span>, nonce));  <br>    <span class="hljs-type">byte</span>[] decryptedData = cipher.doFinal(ciphertext);  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(decryptedData, StandardCharsets.UTF_8);  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="非对称加密（签名验证）">非对称加密（签名验证）</h2><p>我选用的是<code>RSA-PSS</code>签名方案，具体的过程是使用<code>private_key</code>签名，使用<code>public_key</code>验证。<br>这里注意的地方是使用<code>cryptography</code>有可能在Java上无法验证成功，我换了<code>pycryptodome</code>才成功。具体可以看<a href="https://pycryptodome.readthedocs.io/en/latest/src/faq.html#are-rsassa-pss-signatures-compatible-with-java">Frequently Asked Questions — PyCryptodome 3.210b0 documentation</a> ，在用<code>pycryptodome</code>时，使用的命名空间是<code>Crypto</code>，可能与其他的库发生冲突，需要先卸载。<br>另外一个问题是在android中的，在<a href="https://stackoverflow.com/questions/68563437/bouncycastleprovider-not-picked-for-signature-object">java - BouncyCastleProvider not picked for Signature object - Stack Overflow</a>和<a href="https://stackoverflow.com/questions/36829321/change-salt-length-parameter-in-pss-parameters-for-bouncycastle/56064919#56064919">java - Change “salt length” parameter in PSS parameters for Bouncycastle - Stack Overflow</a>提到的问题，Android可能需要在加载pss参数之前就<code>init</code>.<br>同样的，我们在验证的时候也要注意输入的data是原始的未hash过的数据，签名的数据和公钥都是Base64编码的，要注意解码。<br>生成密钥</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.PublicKey <span class="hljs-keyword">import</span> RSA  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_rsa_key_pair</span>(<span class="hljs-params">key_size=<span class="hljs-number">2048</span></span>):  <br><span class="hljs-comment"># 生成 RSA 密钥对  </span><br>key = RSA.generate(key_size)  <br>private_key = key.export_key() <span class="hljs-comment"># 导出私钥  </span><br>public_key = key.publickey().export_key() <span class="hljs-comment"># 导出公钥  </span><br><span class="hljs-keyword">return</span> private_key, public_key  <br>  <br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_key_to_pem</span>(<span class="hljs-params">key: <span class="hljs-built_in">bytes</span>, file_path: <span class="hljs-built_in">str</span></span>):  <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:  <br>file.write(key)  <br>  <br>  <br><span class="hljs-comment"># 生成密钥对  </span><br>private_key, public_key = generate_rsa_key_pair()  <br>  <br><span class="hljs-comment"># 保存私钥和公钥到文件  </span><br>save_key_to_pem(private_key, <span class="hljs-string">&#x27;private_key.pem&#x27;</span>)  <br>save_key_to_pem(public_key, <span class="hljs-string">&#x27;public_key.pem&#x27;</span>)  <br>  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;RSA keys have been generated and saved to &#x27;private_key.pem&#x27; and &#x27;public_key.pem&#x27;.&quot;</span>)<br></code></pre></td></tr></table></figure><p>签名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sign</span>(<span class="hljs-params">data: <span class="hljs-built_in">str</span>, private_key</span>) -&gt; <span class="hljs-built_in">str</span>:  <br><span class="hljs-comment"># 导入私钥  </span><br>key = private_key  <br><span class="hljs-comment"># 创建 SHA256 哈希对象  </span><br>h = SHA256.new(data.encode())  <br><span class="hljs-comment"># 使用 PSS 填充进行签名  </span><br>signer = pss.new(key, salt_bytes=<span class="hljs-number">32</span>)  <br>signature = signer.sign(h)  <br><span class="hljs-comment"># 使用 Base64 编码  </span><br><span class="hljs-keyword">return</span> base64.b64encode(signature).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure><p>验证（Java）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifySignature</span><span class="hljs-params">(String data, String signatureBase64, PublicKey publicKey)</span> <span class="hljs-keyword">throws</span> Exception &#123;    <br>        <span class="hljs-type">Signature</span> <span class="hljs-variable">verifier</span> <span class="hljs-operator">=</span> Signature.getInstance(<span class="hljs-string">&quot;SHA256withRSA/PSS&quot;</span>);  <br>        verifier.initVerify(publicKey);  <br>        <span class="hljs-type">PSSParameterSpec</span> <span class="hljs-variable">pssParams</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PSSParameterSpec</span>(  <br>                <span class="hljs-string">&quot;SHA-256&quot;</span>, <span class="hljs-comment">// Hash algorithm  </span><br>                <span class="hljs-string">&quot;MGF1&quot;</span>, <span class="hljs-comment">// MGF algorithm  </span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">MGF1ParameterSpec</span>(<span class="hljs-string">&quot;SHA-256&quot;</span>), <span class="hljs-comment">// MGF algorithm parameter  </span><br>                <span class="hljs-number">32</span>, <span class="hljs-comment">// Salt length  </span><br>                <span class="hljs-number">1</span>   <br>        );  <br>        verifier.setParameter(pssParams);  <br>  <br>        verifier.update(data.getBytes(StandardCharsets.UTF_8));  <br>        <span class="hljs-type">byte</span>[] signature = Base64.getDecoder().decode(signatureBase64);  <br>        <span class="hljs-keyword">return</span> verifier.verify(signature);  <br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>python</tag>
      
      <tag>Java</tag>
      
      <tag>加密</tag>
      
      <tag>签名</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wav音频格式解析</title>
    <link href="/2024/04/19/wav%E9%9F%B3%E9%A2%91%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/04/19/wav%E9%9F%B3%E9%A2%91%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1>wav音频格式解析</h1><blockquote><p>本文参考：<br><a href="https://www.cnblogs.com/tocy/p/WAV_file-format.html">WAVE文件格式解析 - Tocy - 博客园 (cnblogs.com)</a><br><a href="https://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html">Wave File Specifications (mcgill.ca)</a></p></blockquote><h2 id="简介">简介</h2><p>WAV文件是一种常见的音频文件格式，其结构遵循RIFF（Resource Interchange File Format）规范，这种规范来源于微软和IBM，我们可以在参考博客中找到相关规范文档。</p><p>WAV文件是由<code>chunk</code>组成的，这些chunk通常由ckID、cksize、chunk data组成。</p><h2 id="文件结构">文件结构</h2><p>首先是很经典的结构图：<br><img src="https://img-blog.csdnimg.cn/img_convert/f07387fc9cceaee9000a829dedb813db.gif" alt=""></p><p>这张图中有很多值得注意的地方：</p><ul><li>在最左边表明了当前的字段的编码属于小端模式还是大端模式。</li><li>图中以不同的颜色区分了不同的<code>chunk</code>，而其中的<code>subchunk</code>表明了这些chunk之间的关系。</li><li>每个<code>chunk</code>都有其承载的信息内容，这些信息的组织也有相关规范。</li></ul><p>接下来分别分析其中的chunk</p><blockquote><p>本文中分析hex文件的截图来源于<a href="https://hexed.it/">HexEd.it — 基于浏览器的十六进制编辑器</a></p></blockquote><h3 id="RIFF">RIFF</h3><p>RIFF字段是每个WAV文件都有的部分</p><table><thead><tr><th>field</th><th>Length</th><th>Contents</th></tr></thead><tbody><tr><td>ckid</td><td>4</td><td>“RIFF”</td></tr><tr><td>cksize</td><td>4</td><td>4+n</td></tr><tr><td>WAVEID</td><td>4</td><td>“WAVE”</td></tr><tr><td>WAVE chunks</td><td>n</td><td>包括格式信息和数据块</td></tr></tbody></table><p>这张表列出了RIFFchunk的结构，从中可知：</p><ul><li>其他的信息都在<code>WAVE chunk</code>中，即开始的图中的<code>subchunk</code>部分。</li><li>同时，我们也知道这里的4+n指的是WAVEID的4字节和WAVE chunks的n字节，不包括ckid和cksize。</li><li>RIFF和WAVE属于固定的内容，是不会变的。</li></ul><p><img src="/imgs/2024-04-17/saDZL2nZz5lPxLYk.png" alt="上图是对一个wav的文件放入16进制编辑器分析的截图，我们可以很容易看到转化为ASCII的RIFF和WAV"><br>上图是对一个wav的文件放入16进制编辑器分析的截图，我们可以很容易看到转化为ASCII的RIFF和WAV字段。</p><h3 id="fmt-chunk">fmt chunk</h3><p><code>fmt</code>块是一个可选的块，但是其中包含很多重要的信息，包括channels、sample pre seconds、bits per sample等，所以一般的文件都会有这个块，没有这部分信息很多的播放器会无法解析播放。</p><table><thead><tr><th>Field</th><th>Length</th><th>Contents</th></tr></thead><tbody><tr><td>ckID</td><td>4</td><td>&quot;fmt &quot;</td></tr><tr><td>cksize</td><td>4</td><td>16/18/40</td></tr><tr><td>wFormatTag</td><td>2</td><td>Format code 对应不同的音频编码</td></tr><tr><td>nChannels</td><td>4</td><td>声道数</td></tr><tr><td>nSamplePreSecond</td><td>4</td><td>采样率</td></tr><tr><td>nAvgBytesPerSec</td><td>4</td><td>音频码率</td></tr><tr><td>nBlockAlign</td><td>2</td><td>音频数据块大小</td></tr><tr><td>wBitsPerSample</td><td>2</td><td>量化位数，比如8bit、16bit</td></tr><tr><td><code>cbSize</code></td><td>2</td><td>extension扩展块的大小(0 or 22)</td></tr><tr><td><code>wValidBitsPerSample</code></td><td>2</td><td>有效位数</td></tr><tr><td><code>dwChannelMask</code></td><td>4</td><td>声道掩码，比如左声道、右声道</td></tr><tr><td><code>SubFormat</code></td><td>16</td><td>GUID，数据格式码</td></tr></tbody></table><p>该表格中表示了许多重要信息，我们要注意以下几点：</p><ul><li><code>fmt </code>这个字段占4个字节，最后一个是空。</li><li>当<code>cksize</code>是16是即为没有扩展部分，为18时，对应的<code>cbsize</code>为0，为40时，<code>cbsize</code>为22。</li><li>format code对应的音频编码为下表</li></ul><table><thead><tr><th>Format Code</th><th>PreProcessor Symbol</th><th>Data</th></tr></thead><tbody><tr><td>0x0001</td><td>WAVE_FORMAT_PCM</td><td>PCM</td></tr><tr><td>0x0003</td><td>WAVE_FORMAT_IEEE_FLOAT</td><td>IEEE float</td></tr><tr><td>0x0006</td><td>WAVE_FORMAT_ALAW</td><td>8-bit ITU-T G.711 A-law</td></tr><tr><td>0x0007</td><td>WAVE_FORMAT_MULAW</td><td>8-bit ITU-T G.711 µ-law</td></tr><tr><td>0xFFFE</td><td>WAVE_FORMAT_EXTENSIBLE</td><td>Determined by <code>SubFormat</code></td></tr></tbody></table><blockquote><p>以下内容由AI翻译自第二篇参考文章，我对部分表达做了修改</p></blockquote><h4 id="PCM格式">PCM格式</h4><p>格式块的第一部分用于描述PCM（脉冲编码调制）数据。</p><ul><li>对于PCM数据，文件头中的格式块<code>fmt </code>声明了每个样本中的比特数/样本（wBitsPerSample）。最初的文档规定，每个样本的比特数应向上取整到下一个8比特的倍数。这个向上取整的值就是容器大小。这种信息是多余的，因为每个样本的容器大小（以字节为单位）也可以通过区块大小除以通道数（nBlockAlign / nChannels）来确定。<ul><li>这种冗余已经被用来定义新格式。例如，Cool Edit使用了一个格式，它声明了一个24比特的样本大小，以及一个从区块大小和通道数确定的4字节（32比特）的容器大小。通过这种组合，数据实际上是以32位IEEE浮点数存储的。然而，标准化（全量程223）与标准浮点格式不同。</li></ul></li><li>PCM数据是二进制补码，除了1-8比特的分辨率，它们被表示为偏移二进制。</li></ul><h4 id="非PCM格式">非PCM格式</h4><p>扩展格式块用于非PCM数据。<code>cbSize</code>字段给出了扩展的大小。</p><ul><li>对于除PCM以外的所有格式，格式块必须有一个扩展部分。扩展可以是零长度的，但大小字段（值为0）必须存在。</li><li>对于浮点数据，全量程是1。比特/样本通常为32或64。</li><li>对于对数PCM格式（μ-law和A-law），比特/样本字段（wBitsPerSample）应设置为8比特。</li><li>非PCM格式必须有一个fact块。</li></ul><h4 id="可扩展格式">可扩展格式</h4><p><code>WAVE_FORMAT_EXTENSIBLE</code>格式代码表明格式块有一个扩展。扩展有一个字段，它声明了每个样本的有效比特数（wValidBitsPerSample）。另一个字段（dwChannelMask）包含位，这些位指示从通道到扬声器位置的映射。最后一个字段（SubFormat）是一个16字节的全局唯一标识符（GUID）。</p><ul><li>使用<code>WAVE_FORMAT_EXTENSIBLE</code>格式时，原始的比特/样本字段（wBitsPerSample）必须与容器大小匹配（8 * nBlockAlign / nChannels）。这意味着wBitsPerSample必须是8的倍数。现在通过wValidBitsPerSample指定容器大小内的减少精度。</li><li>有效比特数（wValidBitsPerSample）仅用于信息。数据在容器大小的精度中被正确表示。有效比特数可以是1到容器大小的比特中的任何值。</li><li>扬声器位置掩码使用18位，每位对应一个扬声器位置（例如，前置左或顶部后右），以指示通道到扬声器的映射。这个字段是信息性的。全零字段表明通道按照顺序映射到输出：第一个通道到第一个输出，第二个通道到第二个输出，等等。</li><li>GUID的前两个字节形成指定数据格式代码的子代码，例如<code>WAVE_FORMAT_PCM</code>。其余的14个字节包含一个固定字符串，<code>\x00\x00\x00\x00\x10\x00\x80\x00\x00\xAA\x00\x38\x9B\x71</code>。</li></ul><p>当出现以下情况时，应使用<code>WAVE_FORMAT_EXTENSIBLE</code>格式：</p><ul><li>PCM数据的比特/样本超过16比特。</li><li>通道数超过2。</li><li>实际的比特/样本数不等于容器大小。</li><li>需要指定从通道到扬声器的映射。</li></ul><h3 id="fact-chunk">fact chunk</h3><p>fact是一个可选块，用于记录一些事实信息。所有非pcm编码都必须有fact chunk。Fact块对于所有新的WAVE格式都是必需的，但是对于标准的<code>WAVE_FORMAT_PCM</code>文件则不是必需的。<br>其基本结构如下：</p><table><thead><tr><th>Field</th><th>Length</th><th>Contents</th></tr></thead><tbody><tr><td>ckID</td><td>4</td><td>“fact”</td></tr><tr><td>cksize</td><td>4</td><td>块大小：最小为4</td></tr><tr><td>dwSampleLength</td><td>4</td><td>音频数据的样本大小，以字节为单位</td></tr></tbody></table><h3 id="data-chunk">data chunk</h3><p>data chunk中包含音频的数据。<br>其结构如下：</p><table><thead><tr><th>Field</th><th>Length</th><th>Contents</th></tr></thead><tbody><tr><td>ckID</td><td>4</td><td>“data”</td></tr><tr><td>cksize</td><td>4</td><td>数据大小 n</td></tr><tr><td>sampled data</td><td>n</td><td>数据</td></tr><tr><td>pad byte</td><td>0 or 1</td><td>如果n是奇数，进行填充</td></tr></tbody></table><p>一般来说，常见的音频编码是PCM。在这里简单介绍PCM格式：PCM（Pulse Code Modulation）是一种模拟信号的数字化方法，ADC（Analog to Digital Converter）芯片是实现这一方法的器件。 PCM编码就是这个方法中的数字音频编码方式。PCM编码是最原始的音频编码，其他编码都是在它基础上再次编码和压缩的。</p><p>以下是pcm编码的格式：</p><p><img src="https://img-blog.csdnimg.cn/ac78141e0a514f859acbf592f7bfb9e0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUHJvWXVhbjI4,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p><h3 id="其他chunk">其他chunk</h3><ul><li><code>JUNK</code>是用于对齐的填充段。</li><li><code>bext</code>是由一些广播软件生成的可选段，用于存储元数据信息，如音频文件的标题、艺术家、版权信息等。</li><li><code>LIST </code>是一个特殊的块，用于包含其他子块的列表。标识符为&quot;LIST&quot;，后面跟着一个子块类型的标识符，如&quot;INFO&quot;（用于存储元数据信息）。</li><li><code>INFO Chunk</code>是<code>LIST</code>块的一个子块，用于存储元数据信息，如音频文件的标题、艺术家、版权信息等。标识符为&quot;INFO&quot;。</li><li><code>Cue Point</code>这是一个可选的chunk，它包含了关于音频数据的标记信息，如标记点的位置、名称等。这些信息通常用于在音频播放器中添加书签或跳转到特定位置。</li><li><code>slnt</code> 通常用于存储音频文件的缩略图或预览图像，它通常出现在音频文件的元数据中，而不是音频数据本身。</li><li>其他的块在参考博客的链接文档中有详细介绍</li></ul><h2 id="例子">例子</h2><p>在我的两篇参考博客中都有例子，可以直接参考对照。另附一个博客中的例子，有图和直接的16进制数据对照：<a href="https://www.cnblogs.com/muxue/archive/2010/04/19/1715715.html">WAVE 文件格式分析 - 唐风思琪 - 博客园 (cnblogs.com)</a></p><h2 id="总结">总结</h2><ul><li>如果我们想要实现一个wav文件的播放器，那么我们需要关心的chunk包括<code>RIFF</code>、<code>fmt </code>和<code>data</code>，其他的块中的内容不是必须的。</li><li>这些块的结构是有规律的：4个字节的标识符以及紧接着的4个字节的chunk大小。这一规律使得我们尽管不完全知道wav的chunk种类也能找到我们需要的信息：保留自己需要的块，跳过不认识的块。</li><li>在<code>fmt </code>中包含了解析data的重要参数，我们要比较了解这一部分内容。本文也花了不少篇幅在这部分，例子中的大部分也是在分析fmt chunk。</li><li>在我查找资料的过程中，我发现了这个项目：<a href="https://github.com/jazzlost/WavParser">jazzlost/WavParser: Wave Formate File Parser (github.com)</a>。这个项目用c++实现了wav的解析，可以直接运行，可以作为参考学习。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>音频开发</tag>
      
      <tag>总结</tag>
      
      <tag>读说明书</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
